<!doctype html>
<meta charset="utf-8">
<title>Treasure hunter</title>
<body>
  <div id="debug">
  <div id="playerCurrent">
    <span class="label">Current</span>
    <span class="data"></span>
  </div>
  <div id="playerNorth">
    <span class="label">North</span>
    <span class="data"></span>
  </div>
  <div id="playerEast">
    <span class="label">East</span>
    <span class="data"></span>
  </div>
  <div id="playerSouth">
    <span class="label">South</span>
    <span class="data"></span>
  </div>
  <div id="playerWest">
    <span class="label">West</span>
    <span class="data"></span>
  </div>
</div>
<!-- Import the Ga game engine files -->
<script src="ga.js"></script>
<script src="../plugins.js"></script>
<script src="../custom.js"></script>
<script>
//All of your game code will go here
var g = ga(
  1024, 768, setup,
  [
    "chimes.wav",
    'world.json',
    'tileset.png',
    'player.png',
  ]
);
/***********************************************************************************
General TODO List:

-- Add diagonal tiles to getAdjacentTiles

-- Implement down-right & down-left tile destruction mechanic

-- Implement level-end mechanic (direction UP @ door)

-- Add enemies

-- Add sounds

***********************************************************************************/

//Start the Ga engine
g.start();
//Declare your global variables (global to this game)
var dungeon, player, treasure, enemies, chimes, exit,
    healthBar, message, gameScene, gameOverScene;

//The `setup` function will run only once.
//Use it for initialization tasks
function setup() {
  //Set the canvas border and background color
  g.canvas.style.border = "none";
  g.backgroundColor = "black";

  world = g.makeTiledWorld('world.json', 'tileset.png');

  // console.log('World:', world);
  // console.log(world.objects[0].data);

  //Create the `gameScene` group
  gameScene = g.group();

  // Create reference to level tiles
  exit = world.getObject(g.tileTypes.door);
  airs = world.getObjects(g.tileTypes.air);
  floors = world.getObjects(g.tileTypes.floor);
  ladders = world.getObjects(g.tileTypes.ladder);

  // Render level tiles
  floors.forEach(floor => {
    gameScene.addChild(floor);
  })
  airs.forEach(air => {
    gameScene.addChild(air);
  })
  ladders.forEach(ladder => {
    gameScene.addChild(ladder);
  })
  gameScene.addChild(exit);

  // Create and render player
  player = g.sprite('player.png');
  player.x = 352;
  player.y = 704;
  gameScene.addChild(player);

  //Add some text for the game over message
  message = g.text("Game Over!", "64px Futura", "black", 20, 20);
  message.x = 120;
  message.y = g.canvas.height / 2 - 64;
  //Create a `gameOverScene` group and add the message sprite to it
  gameOverScene = g.group(message);
  //Make the `gameOverScene` invisible for now
  gameOverScene.visible = false;
  //Assign the player's keyboard controllers
  // g.fourKeyController(player, 2, 38, 39, 40, 37);
  //You can also do it the long way, like this:

  //Left arrow key `press` method
  directions = {
    up: 'u',
    down: 'd',
    left: 'l',
    right: 'r',
    still: 'still',
  }

  movement = {
    falling: false,
    moving: false,
    direction: directions.still,
  }

  g.key.rightArrow.press = function() {
    // moveOneTile(directions.right);
    movement.direction = directions.right;
  };
  g.key.leftArrow.press = function() {
    // moveOneTile(directions.left);
    movement.direction = directions.left;
  };
  g.key.upArrow.press = function() {
    // moveOneTile(directions.up);
    movement.direction = directions.up;
  };
  g.key.downArrow.press = function() {
    // moveOneTile(directions.down);
    movement.direction = directions.down;
  };
  g.key.a.press = function() {
    // moveOneTile(directions.down);
    destroyBlock('dl');
  };
  g.key.d.press = function() {
    // moveOneTile(directions.down);
    destroyBlock('dr');
  };

  g.key.rightArrow.release = function() {
    if(movement.direction === directions.right) {
      movement.direction = directions.still;
    }
  };
  g.key.leftArrow.release = function() {
    if(movement.direction === directions.left) {
      movement.direction = directions.still;
    }
  };
  g.key.upArrow.release = function() {
    if(movement.direction === directions.up) {
      movement.direction = directions.still;
    }
  };
  g.key.downArrow.release = function() {
    if(movement.direction === directions.down) {
      movement.direction = directions.still;
    }
  };

  //set the game state to `play`
  g.state = play;
}

destroyedBlockQueue = [];

function destroyBlock(dir) {
  currentTile = g.getSpriteIndex(player);
  
  tileToDestroy = g.getAdjacentTile(currentTile, dir);

  console.log('BTD', tileToDestroy);
  console.log('World', world.children[0].data[tileToDestroy.index]);

  spriteToDestroy = floors.find(el => {
    return el.index === tileToDestroy.index;
  })

  if(spriteToDestroy.visible) {
    // spriteToDestroy.visible = !spriteToDestroy.visible;
    world.children[0].data[tileToDestroy.index] = 1;
    g.fadeOut(spriteToDestroy, 15);
    destroyedBlockQueue.push({'sprite': spriteToDestroy, 'tile': tileToDestroy, 'time': Date.now()});
  }
}

function respawnBlock(blockObj) {
  let tween = g.fadeIn(blockObj.sprite, 15)
  world.children[0].data[blockObj.tile.index] = 2;
  // tween.onComplete = function(obj) {
  // };
  // blockObj.sprite.visible = true;
}

function moveOneTile(sprite, dir) {
  currentTile = g.getSpriteIndex(sprite);
  adjacentTiles = g.getAdjacentTiles(currentTile);
  canMove = false;

  switch(dir) {
    case directions.up:
      if(adjacentTiles.u.type && 
        adjacentTiles.c.type === g.tileTypes.ladder && 
        adjacentTiles.u.type !== g.tileTypes.floor) {
        canMove = true;
      }
    break;
    case directions.down:
      if(adjacentTiles.d.type && adjacentTiles.c.type === g.tileTypes.ladder && adjacentTiles.d.type !== g.tileTypes.floor || 
        adjacentTiles.d.type && adjacentTiles.d.type === g.tileTypes.ladder ||
        adjacentTiles.d.type && movement.falling) {
        console.log(adjacentTiles.d.type);
        canMove = true;
      }
    break;
    case directions.right:
      if(adjacentTiles.r.type && adjacentTiles.r.type !== g.tileTypes.floor) {
        canMove = true;
      }
    break;
    case directions.left:
      if(adjacentTiles.l.type && adjacentTiles.l.type !== g.tileTypes.floor) {
        canMove = true;
      }
    break;
  }

  if(canMove) {
    currentCoords = g.getTile(currentTile, world.objects[0].data, world);
    nextCoords = g.getTile(adjacentTiles[dir].index, world.objects[0].data, world);
    nextX = nextCoords.x;
    nextY = nextCoords.y;
    sprite.x = nextX;
    sprite.y = nextY;
    checkIfFalling(sprite);
  } else {
    return false;
  }

  return true;

  function checkIfFalling(sprite) {
    currentTile = g.getSpriteIndex(sprite);
    adjacentTiles = g.getAdjacentTiles(currentTile);

    if(adjacentTiles.c.type !== g.tileTypes.ladder && adjacentTiles.d.type === g.tileTypes.air) {
      movement.falling = true;
    } else {
      movement.falling = false;
    }
  }
}

function moveAgain() {
  movement.moving = false;
}

$playerCurrent = document.getElementById('playerCurrent').querySelector('.data');
$playerNorth = document.getElementById('playerNorth').querySelector('.data');
$playerEast = document.getElementById('playerEast').querySelector('.data');
$playerSouth = document.getElementById('playerSouth').querySelector('.data');
$playerWest = document.getElementById('playerWest').querySelector('.data');

//The `play` state
function play() {
  //Move the player
  currentTile = g.getSpriteIndex(player);
  // playerData = g.getAdjacentTiles(currentTile);
  
  if (destroyedBlockQueue.length && Date.now() - destroyedBlockQueue[0].time > 500) {
    respawnBlock(destroyedBlockQueue.shift());
  } 

  if(movement.direction !== directions.still && !movement.moving || movement.falling && !movement.moving) {
    if(movement.falling) {
      didMove = moveOneTile(player, directions.down);
    } else {
      didMove = moveOneTile(player, movement.direction);
    }
    
    if(didMove) {
      movement.moving = true;
      g.wait(150, moveAgain);
    }
  }

  // $playerCurrent.innerHTML = `${playerData.c.index} - ${playerData.c.type}`;
  // $playerNorth.innerHTML = `${playerData.u.index} - ${playerData.u.type}`;
  // $playerEast.innerHTML = `${playerData.r.index} - ${playerData.r.type}`;
  // $playerSouth.innerHTML = `${playerData.d.index} - ${playerData.d.type}`;
  // $playerWest.innerHTML = `${playerData.l.index} - ${playerData.l.type}`;
  
  // g.move(player, playerData);

  //Keep the player contained inside the stage's area
  g.contain(player, g.stage.localBounds);

  //Check for the end of the game
  //Does the player have enough health? If the width of the `innerBar`
  //is less than zero, end the game and display "You lost!"
  if (1 < 0) {
    g.state = end;
    message.content = "You lost!";
  }
  //If the player has brought the treasure to the exit,
  //end the game and display "You won!"
  // if (g.hitTestRectangle(player, exit)) {
  //   g.state = end;
  //   message.content = "You won!";
  // }
}
function end() {
  //Hide the `gameScene` and display the `gameOverScene`
  gameScene.visible = false;
  gameOverScene.visible = true;
}
</script>

</body>